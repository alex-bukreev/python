# Игра в 16

Это очень известная простая игра, которую можно встретить в различных вариантах. У нас будет так:

На столе лежат 16 карточек рубашками вверх. На лицевой стороне карточек какие-то картинки, например буквы. Всего восемь разных картинок, каждая встречается два раза. Игрок может перевернуть две карточки и увидеть их картинки. Если картинки совпадают, карточки удаляются. Если картинки разные, карточки переворачиваются назад рубашками вверх. Задача игрока -- найти все пары одинаковых карточек.


## Установка pgzero

Сначала надо установить пакет pgzero. Сделаем это с помощью установщика пакетов pip (обычно он устанавливается вместе с питоном). В Windows для этого надо:

1. Открыть терминал. Для этого нажимаем на клавиатуре ```Win```+```R```, в появившемся окошке вводим ```cmd``` и нажимаем ```Enter```.

2. В терминале (обычно это черное окно) вводим команду

	py -m pip install pgzero

и нажимаем ```Enter```.

Для проверки запустите в питоне простейшую программу. Она подключает библиотеку ```pgzrun``` и запускает игру функцией ```go``` из этой библиотеки:

	import pgzrun
	pgzrun.go()

Должно появиться небольшое черное окно.


## Этап 1. Графика.

В папке с файлом игры должна располагаться папка ```images``` с изображениями, которые будут выводиться на экран. Мы назовем их: ```desk.png``` (фон), ```back``` (рубашка), от ```0.png``` до ```7.png``` (картинки на карточках). Готовые изображения мы можете скачать здесь из репозитория или можете сделать самостоятельно.

Я сделал карточки размером 100 на 100 и фон размером 500 на 500 пикселей. Как раз помещаются по четыре карточки в ширину и высоту с промежутками в 20 пикселей.

В начале программы надо задать размеры окна. Компьютер будет искать их в переменных с названиями ```WIDTH``` (ширина) и ```HEIGHT``` (высота):

	WIDTH = 500
	HEIGHT = 500

Теперь переходим к рисованию. Мы должны написать для этого функцию с названием ```draw```:

	def draw(): 

Далее с отступом пишем функцию:

	screen.blit('desk',(0,0))

Эта функция поместит на экран изображение из файла ```desk.png``` из папки ```images```. Причем поместит ее так, что левый верхний угол картинки окажется в точке с координатами (0,0), то есть в левый верхний угол окна. Получается фоновое изображение полностью закроет окно.

Дальше располагаем карточки. Тут потребуется цикл ```for i in range(16):```. Для каждой карточки надо определить ее положение на экране. Если пронумеровать столбцы и строки числами от 0 до 3, то i-я карточка должна попасть в столбец номер ```i%4``` (остаток при делении на 4) и строку номер ```i//4``` (неполное частное при делении на 4):
![-](step-0a.png "Номера столбца и строки")

А потом надо перевести номера столбца и строки в координаты, то есть количества пикселей, которые надо отступить от левого верхнего угла окна. Он считаются так (пояснение на картинке ниже):

	x = 20 + 120*(i%4)
	y = 20 + 120*(i//4)

![-](step-0b.png "Координаты карточек")

И теперь нарисуем в этом месте карточку рубашкой вверх:

	screen.blit('back',(x,y))

Таким образом, получается программа:

	import pgzrun
	WIDTH = 500
	HEIGHT = 500

	def draw():
		screen.blit('desk',(0,0))
		for i in range(16):
			x = 20 + 120*(i%4)
			y = 20 + 120*(i//4)
			screen.blit('back',(x,y))

	pgzrun.go()

Запустите ее. На экране должна появиться такая картина:
![-](step-1.png "Рубашки вверх")


## Этап 2. Случайность.

Научимся перетасовывать карты. Нам поможет библиотека математически функций ```numpy```:

	import numpy

В ее разделе ```random``` есть функция ```permutation``` (по русски -- перестановка), которая перемешивает массив. В начале программы мы введем массив ```card```, который будет хранить номера картинок карт. То есть ```card[i]``` -- это номер картинки i-й карты.

	card = numpy.random.permutation([0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7])

В строке, где мы рисуем карту, заменяем ```'back'``` на ```str(card[i])```. И теперь карты оказываются открыты и перетасованы случайным образом.
![-](step-2.png "Случайное расположение")


## Этап 3. Состояния.

Добавим картам разные состояния. Договоримся считать, что 0 -- это "закрыта", 1 -- "открыта", а 2 -- "удалена".

В начале программы вводим массив для хранения состояний карт. Заполним его как-нибудь:

	state = [0,0,1,2,0,0,1,0,0,1,1,2,0,0,1,2]

А в том месте, где мы рисовали карты, заменим это на условный оператор ```if``` с проверкой состояния карты: если состояние ```state[i]``` равно нулю -- рисуем рубашку, если 1 -- рисуем картинку, если 2 -- ничего не делаем:

	if state[i]==0:
		screen.blit('back',(x,y))
	elif state[i]==1:
		screen.blit(str(card[i]),(x,y))

Получается вот так:
![-](step-3.png "Разные состояния")


## Этап 4. Мышь.

Теперь добавим возможнось переворачивать карты. Надо добавить в программу функцию с названием ```on_mouse_down```. Она будет вызываться при нажатии на кнопку мыши и получать в качестве аргумента координаты курсора в этот момент в виде массива из двух чисел, который мы назовем ```pos```:

	def on_mouse_down(pos):
		global state
		for i in range(16):
			x = 20 + 120*(i%4)
			y = 20 + 120*(i//4)
			if x<pos[0]<x+100 and y<pos[1]<y+100:
				state[i] = 1

Внутри функции мы с помощью цикла походим по всем картам и отпределяем, попал ли по ним курсор мыши. Мы уже выше вычисляли координаты левого верхнего угла карты x и y. Теперь мы проверяем, попал ли курсор в прямоугольник от x до x+100 по горизонтали и от y до y+100 по вертикали. Если да, то меняем состояние карты на 1 -- "открыта".

Строка ```global state``` нужна для того, чтобы *внутри* функции можно было изменять переменные введеные *снаружи*.


## Этап 5. Логика.

Осталось добавить игре логику. Введем две переменые ```a``` и ```b``` для запоминания, какие карты открыты в данный момент. В начале напишем

	a = None
	b = None

В функцию ```on_mouse_down``` надо добавить строку ```global a,b```, потому что мы собираемся изменять значения этих переменных при нажатии.

Но главное, вместо ```state[i] = 1``` в этой же функции мы будем делать проверку, в каком изтрех состояний находится игра:

**1.** Если открытых карт нет (обе переменные равны ```None```) и нажатие было на закрытую карту (учитываем, что могут быть уже удаленные карты), то надо открыть эту карту, а ее номер записать в ```a```.

	if a==None and b==None and state[i]==0:
		a = i
		state[i] = 1

**2.** Если открыта одна карта (```a``` не равно ```None```, но ```b``` равно ```None```) и нажатие было на закрытую карту, то ее надо открыть и записать номер в ```b```. А после этого сделать проверку, не совпадают ли картинки на открытых картах, и если да, удалить их (изменить состояние на 2) и записать в переменные ```a``` и ```b``` значение ```None```.

	elif a!=None and b==None and state[i]==0:
		b = i
		state[i] = 1
		if card[a]==card[b]:
			state[a] = 2
			state[b] = 2
			a = None
			b = None

**3.** Если открыты две карты (обе переменные равны ```None```), то значит они не совпадают (иначе бы мы их удалили сразу при открытии). Поэтому мы их закрываем и записываем в ```a``` и ```b``` значение ```None```.

	elif a!=None and b!=None:
		state[a] = 0
		state[b] = 0
		a = None
		b = None


## Конец

Все, игра готова! Вот ее полный текст:

	import pgzrun
	import numpy
	WIDTH = 500
	HEIGHT = 500
	card = numpy.random.permutation([0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7])
	state = [0]*16
	a = None
	b = None

	def draw():
		screen.blit('desk',(0,0))
		for i in range(16):
			x = 20 + 120*(i%4)
			y = 20 + 120*(i//4)
			if state[i]==0:
				screen.blit('back',(x,y))
			elif state[i]==1:
				screen.blit(str(card[i]),(x,y))

	def on_mouse_down(pos):
		global a,b
		for i in range(16):
			x = 20 + 120*(i%4)
			y = 20 + 120*(i//4)
			if x<pos[0]<x+100 and y<pos[1]<y+100:
				if a==None and state[i]==0:
					a = i
					state[i] = 1
				elif a!=None and b==None and state[i]==0:
					b = i
					state[i] = 1
					if card[a]==card[b]:
						state[a] = 2
						state[b] = 2
						a = None
						b = None
				elif b!=None:
					state[a] = 0
					state[b] = 0
					a = None
					b = None

	pgzrun.go()

![-](done.png "Готово!")

В ней нет сообщения о победе. Вы можете добавить его сами.
